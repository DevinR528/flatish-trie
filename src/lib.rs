//!
//! A flattened trie that uses indexes into a flat HashMap<T> where T is the single element of a
//! sequence.
//! 
//! for "cat" and "cow" 
//! {
//!     hash of ([], 'c'): Node { children: [hashes of (['c'], 'a'), (['c], 'o')]},
//!     ([], 'a'): Node { children: [hash of (['c', 'a'], 't')] },
//!     ([], 't'): Node { children: [] },
//!     ([], 'o'): Node { children: [hash of (['c', 'o'], 'w')] },
//!     ([], 'w'): Node { children: [] },
//! }
//! asking for "c" would find the index of "c" using a hash of ([], 'c')
//! [a, c, o, t, w]
//!     ^
//! which gives indexes into the children of 'c' generated by (['c'], 'o') or 
//! (['c'], 'a') respectively.
//! [a, c, o, t, w]
//!  ^     ^
//! and again for each child recursively
//! [a, c, o, t, w]
//!           ^  ^ o's 
//!          a's
//! <br>
use std::fmt::Debug;
use std::hash::{Hash, Hasher};

use fnv::FnvHasher;

mod noop_hash;
pub use noop_hash::PreHashedMap;
mod node;
use node::{Node};

pub(crate) fn fnv_hash<T>(to_hash: (&[T], &T)) -> u64 
where 
    T: Hash,
{
    let mut hasher = FnvHasher::default();
    to_hash.hash(&mut hasher);
    hasher.finish()
}

#[derive(Debug, Clone)]
pub struct Trie<T> {
    starts: Vec<u64>,
    children: PreHashedMap<u64, Node<T>>
}
impl<T> Default for Trie<T> {
    fn default() -> Self {
        Self {
            children: PreHashedMap::default(),
            starts: Vec::default(),
        }
    }
}

impl<T> Trie<T> 
where
    T: Eq + Hash + Clone,
{
    pub fn new() -> Self {
        Trie { children: PreHashedMap::default(), starts: Vec::default(), }
    }

    fn _insert(&mut self, seq: &[T], val: Option<T>, mut idx: usize) {
        if let Some(val) = val {
            let key = fnv_hash((&seq[..idx], &val));
            // let key = (&seq[..idx], &val);

            if self.children.contains_key(&key) {
                // add new keys to Node.children vec
                // we just checked its in here
                let node = self.children.get_mut(&key).unwrap();
                node.update_children(seq, idx);
                idx += 1;
                if let Some(next) = seq.get(idx) {
                    self._insert(seq, Some(next.clone()), idx);
                    return;
                }
            }

            let terminal = seq.len() == idx + 1;
            let node = Node::new(val, &seq, idx, terminal);
            self.children.insert(key, node);
            idx += 1;
            if let Some(next) = seq.get(idx) {
                self._insert(seq, Some(next.clone()), idx)
            }
        }
    }

    pub fn insert(&mut self, seq: &[T]) {
        if let Some(first) = seq.first() {
            let key = fnv_hash((&[], first));
            if !self.starts.contains(&key) { self.starts.push(key) };
            self._insert(seq, Some(first.clone()), 0)
        }
    }

    /// Returns all of the found sequences, walking
    /// each branch depth first.
    ///
    /// # Examples
    ///
    /// ```
    /// use ecs_trie::Trie;
    /// let mut trie = Trie::new();
    /// trie.insert(&['c', 'a', 't']);
    /// trie.insert(&['c', 'o', 'w']);
    /// 
    /// let found = trie.search(&['c']);
    /// 
    /// assert_eq!(
    ///     found.as_collected().as_slice(),
    ///     &[ ['c', 'a', 't'], ['c', 'o', 'w'] ]
    /// );
    /// ```
    pub fn search(&self, seq_key: &[T]) -> Found<T> {
        let i = seq_key.len() - 1;
        let key = fnv_hash((&seq_key[..i], &seq_key[i]));
        // let key = (&seq_key[..i], &seq_key[i]);
        let mut res = Found::new();
        if let Some(node) = self.children.get(&key) {
            res.push_val(node.val.clone());
            Trie::_search(&self.children, node, seq_key, 1, &mut res)
        }
        res
    }

    fn _search<'n>(
        map: &PreHashedMap<u64, Node<T>>,
        node: &'n Node<T>,
        seq_key: &[T],
        idx: usize,
        found: &mut Found<T>
    ) {        
        if let Some(k) = seq_key.get(idx) {
            let key = fnv_hash((&seq_key[0..idx], k));
            if let Some(n) = map.get(&key) {
                found.push_val(n.to_value());
                // found.branch_split(node.as_value());
                Trie::_search(map, n, seq_key, idx + 1, found);
            }
        } else {
            // complete terminal branch no children
            if node.is_terminal() && node.child_len() == 0 {
                found.branch_end();
                return;
            // terminal but children after
            } else if node.is_terminal() {
                found.branch_end_continue();
            }
            // recurs iteratively over children
            for n in node.children(map) {
                found.push_val(n.to_value());
                Trie::_search(map, n, seq_key, idx + 1, found);

                // not terminal but has more than one child, if deeper than single
                // node we need a some way of keeping track of what needs to be removed
                // from temp vec
                if !node.is_terminal() && node.child_len() > 1 {
                    found.branch_split(node.as_value());
                }
            }
        }
    }

    pub fn iter(&self) -> TrieIter<T> {
        TrieIter {
            trie: self,
            current: None,
            starts: &self.starts,
            children: Vec::default(),
            idx: 0,
            next_idx: 0,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Found<T> {
    roll_back: Vec<usize>,
    temp: Vec<T>,
    collected: Vec<Vec<T>>,
}
impl<T: Clone + PartialEq> Found<T> {
    fn new() -> Self {
        Self {
            roll_back: vec![],
            temp: vec![],
            collected: vec![],
        }
    }

    pub fn as_collected(&self) -> Vec<&[T]> {
        self.collected
            .iter()
            .map(|seq| seq.as_slice())
            .collect::<Vec<_>>()
    }

    fn push_val(&mut self, t: T) {
        self.temp.push(t);
    }

    fn branch_end_continue(&mut self) {
        self.collected.push(self.temp.clone());
    }

    fn branch_split(&mut self, key: &T) {
        if let Some(idx) = self.temp.iter().position(|item| key == item) {
            let (start, _end) = self.temp.split_at(idx + 1);
            self.temp = start.to_vec();
        }
    }

    fn branch_end(&mut self) {
        self.collected.push(self.temp.clone());
        // remove last element
        self.temp.pop();
    }
}

pub struct TrieIter<'a, T> {
    trie: &'a Trie<T>,
    current: Option<&'a Node<T>>,
    starts: &'a [u64],
    children: Vec<u64>,
    idx: usize,
    next_idx: usize,
}
impl<'a, T> Iterator for TrieIter<'a, T> 
where
    T: Clone + Eq + Hash,
{
    type Item = &'a Node<T>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.current.is_none() {
            // this bails us out of the iteration
            let key = self.starts.get(self.idx)?;
            self.current = Some(self.trie.children.get(&key)?);
            self.idx += 1;
            // we know its there
            self.children = self.current.unwrap()
                .walk(self.trie)
                .map(|n| n.key)
                .collect::<Vec<_>>();

            self.current
        } else {
            let key = self.children[self.next_idx];
            self.current = self.trie.children.get(&key);
            self.next_idx += 1;

            if self.next_idx >= self.children.len() {
                self.next_idx = 0;
                let curr = self.current.take();
                curr
            } else {
                self.current
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn insert_find() {
        let mut trie = Trie::new();
        trie.insert(&['c', 'a', 't']);
        trie.insert(&['c', 'o', 'w']);
        let found = trie.search(&['c']);
        println!("{:?}", found);
    }

    #[test]
    fn trie_iter() {
        let mut trie = Trie::new();
        trie.insert(&['c', 'a', 't']);
        trie.insert(&['c', 'o', 'w']);
        for n in trie.iter() {
            println!("{:?}", n);
        }
    }
}
